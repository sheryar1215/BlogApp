"use strict";

/**
 * Parse Server authentication adapter for Facebook.
 *
 * @class FacebookAdapter
 * @param {Object} options - The adapter configuration options.
 * @param {string} options.appSecret - Your Facebook App Secret. Required for secure authentication.
 * @param {string[]} options.appIds - An array of Facebook App IDs. Required for validating the app.
 *
 * @description
 * ## Parse Server Configuration
 * To configure Parse Server for Facebook authentication, use the following structure:
 * ```json
 * {
 *   "auth": {
 *     "facebook": {
 *       "appSecret": "your-app-secret",
 *       "appIds": ["your-app-id"]
 *     }
 *   }
 * }
 * ```
 *
 * The adapter supports the following authentication methods:
 * - **Standard Login**: Requires `id` and `access_token`.
 * - **Limited Login**: Requires `id` and `token`.
 *
 * ## Auth Payloads
 * ### Standard Login Payload
 * ```json
 * {
 *   "facebook": {
 *     "id": "1234567",
 *     "access_token": "abc123def456ghi789"
 *   }
 * }
 * ```
 *
 * ### Limited Login Payload
 * ```json
 * {
 *   "facebook": {
 *     "id": "1234567",
 *     "token": "xxxxx.yyyyy.zzzzz"
 *   }
 * }
 * ```
 *
 * ## Notes
 * - **Standard Login**: Use `id` and `access_token` for full functionality.
 * - **Limited Login**: Use `id` and `token` (JWT) when tracking is opted out (e.g., via Apple's App Tracking Transparency).
 * - Supported Parse Server versions:
 *   - `>= 6.5.6 < 7`
 *   - `>= 7.0.1`
 *
 * Secure authentication is recommended to ensure proper data protection and compliance with Facebook's guidelines.
 *
 * @see {@link https://developers.facebook.com/docs/facebook-login/limited-login/ Facebook Limited Login}
 * @see {@link https://developers.facebook.com/docs/facebook-login/facebook-login-for-business/ Facebook Login for Business}
 */

// Helper functions for accessing the Facebook Graph API.
const Parse = require('parse/node').Parse;
const crypto = require('crypto');
const jwksClient = require('jwks-rsa');
const jwt = require('jsonwebtoken');
const httpsRequest = require('./httpsRequest');
const authUtils = require('./utils');
const TOKEN_ISSUER = 'https://www.facebook.com';
function getAppSecretPath(authData, options = {}) {
  const appSecret = options.appSecret;
  if (!appSecret) {
    return '';
  }
  const appsecret_proof = crypto.createHmac('sha256', appSecret).update(authData.access_token).digest('hex');
  return `&appsecret_proof=${appsecret_proof}`;
}
function validateGraphToken(authData, options) {
  return graphRequest('me?fields=id&access_token=' + authData.access_token + getAppSecretPath(authData, options)).then(data => {
    if (data && data.id == authData.id || process.env.TESTING && authData.id === 'test') {
      return;
    }
    throw new Parse.Error(Parse.Error.OBJECT_NOT_FOUND, 'Facebook auth is invalid for this user.');
  });
}
async function validateGraphAppId(appIds, authData, options) {
  var access_token = authData.access_token;
  if (process.env.TESTING && access_token === 'test') {
    return;
  }
  if (!Array.isArray(appIds)) {
    throw new Parse.Error(Parse.Error.OBJECT_NOT_FOUND, 'appIds must be an array.');
  }
  if (!appIds.length) {
    throw new Parse.Error(Parse.Error.OBJECT_NOT_FOUND, 'Facebook auth is not configured.');
  }
  const data = await graphRequest(`app?access_token=${access_token}${getAppSecretPath(authData, options)}`);
  if (!data || !appIds.includes(data.id)) {
    throw new Parse.Error(Parse.Error.OBJECT_NOT_FOUND, 'Facebook auth is invalid for this user.');
  }
}
const getFacebookKeyByKeyId = async (keyId, cacheMaxEntries, cacheMaxAge) => {
  const client = jwksClient({
    jwksUri: `${TOKEN_ISSUER}/.well-known/oauth/openid/jwks/`,
    cache: true,
    cacheMaxEntries,
    cacheMaxAge
  });
  let key;
  try {
    key = await authUtils.getSigningKey(client, keyId);
  } catch (error) {
    throw new Parse.Error(Parse.Error.OBJECT_NOT_FOUND, `Unable to find matching key for Key ID: ${keyId}`);
  }
  return key;
};
const verifyIdToken = async ({
  token,
  id
}, {
  clientId,
  cacheMaxEntries,
  cacheMaxAge
}) => {
  if (!token) {
    throw new Parse.Error(Parse.Error.OBJECT_NOT_FOUND, 'id token is invalid for this user.');
  }
  const {
    kid: keyId,
    alg: algorithm
  } = authUtils.getHeaderFromToken(token);
  const ONE_HOUR_IN_MS = 3600000;
  let jwtClaims;
  cacheMaxAge = cacheMaxAge || ONE_HOUR_IN_MS;
  cacheMaxEntries = cacheMaxEntries || 5;
  const facebookKey = await getFacebookKeyByKeyId(keyId, cacheMaxEntries, cacheMaxAge);
  const signingKey = facebookKey.publicKey || facebookKey.rsaPublicKey;
  try {
    jwtClaims = jwt.verify(token, signingKey, {
      algorithms: algorithm,
      // the audience can be checked against a string, a regular expression or a list of strings and/or regular expressions.
      audience: clientId
    });
  } catch (exception) {
    const message = exception.message;
    throw new Parse.Error(Parse.Error.OBJECT_NOT_FOUND, `${message}`);
  }
  if (jwtClaims.iss !== TOKEN_ISSUER) {
    throw new Parse.Error(Parse.Error.OBJECT_NOT_FOUND, `id token not issued by correct OpenID provider - expected: ${TOKEN_ISSUER} | from: ${jwtClaims.iss}`);
  }
  if (jwtClaims.sub !== id) {
    throw new Parse.Error(Parse.Error.OBJECT_NOT_FOUND, 'auth data is invalid for this user.');
  }
  return jwtClaims;
};

// Returns a promise that fulfills iff this user id is valid.
function validateAuthData(authData, options) {
  if (authData.token) {
    return verifyIdToken(authData, options);
  } else {
    return validateGraphToken(authData, options);
  }
}

// Returns a promise that fulfills iff this app id is valid.
function validateAppId(appIds, authData, options) {
  if (authData.token) {
    return Promise.resolve();
  } else {
    return validateGraphAppId(appIds, authData, options);
  }
}

// A promisey wrapper for FB graph requests.
function graphRequest(path) {
  return httpsRequest.get('https://graph.facebook.com/' + path);
}
module.exports = {
  validateAppId: validateAppId,
  validateAuthData: validateAuthData
};
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJuYW1lcyI6WyJQYXJzZSIsInJlcXVpcmUiLCJjcnlwdG8iLCJqd2tzQ2xpZW50Iiwiand0IiwiaHR0cHNSZXF1ZXN0IiwiYXV0aFV0aWxzIiwiVE9LRU5fSVNTVUVSIiwiZ2V0QXBwU2VjcmV0UGF0aCIsImF1dGhEYXRhIiwib3B0aW9ucyIsImFwcFNlY3JldCIsImFwcHNlY3JldF9wcm9vZiIsImNyZWF0ZUhtYWMiLCJ1cGRhdGUiLCJhY2Nlc3NfdG9rZW4iLCJkaWdlc3QiLCJ2YWxpZGF0ZUdyYXBoVG9rZW4iLCJncmFwaFJlcXVlc3QiLCJ0aGVuIiwiZGF0YSIsImlkIiwicHJvY2VzcyIsImVudiIsIlRFU1RJTkciLCJFcnJvciIsIk9CSkVDVF9OT1RfRk9VTkQiLCJ2YWxpZGF0ZUdyYXBoQXBwSWQiLCJhcHBJZHMiLCJBcnJheSIsImlzQXJyYXkiLCJsZW5ndGgiLCJpbmNsdWRlcyIsImdldEZhY2Vib29rS2V5QnlLZXlJZCIsImtleUlkIiwiY2FjaGVNYXhFbnRyaWVzIiwiY2FjaGVNYXhBZ2UiLCJjbGllbnQiLCJqd2tzVXJpIiwiY2FjaGUiLCJrZXkiLCJnZXRTaWduaW5nS2V5IiwiZXJyb3IiLCJ2ZXJpZnlJZFRva2VuIiwidG9rZW4iLCJjbGllbnRJZCIsImtpZCIsImFsZyIsImFsZ29yaXRobSIsImdldEhlYWRlckZyb21Ub2tlbiIsIk9ORV9IT1VSX0lOX01TIiwiand0Q2xhaW1zIiwiZmFjZWJvb2tLZXkiLCJzaWduaW5nS2V5IiwicHVibGljS2V5IiwicnNhUHVibGljS2V5IiwidmVyaWZ5IiwiYWxnb3JpdGhtcyIsImF1ZGllbmNlIiwiZXhjZXB0aW9uIiwibWVzc2FnZSIsImlzcyIsInN1YiIsInZhbGlkYXRlQXV0aERhdGEiLCJ2YWxpZGF0ZUFwcElkIiwiUHJvbWlzZSIsInJlc29sdmUiLCJwYXRoIiwiZ2V0IiwibW9kdWxlIiwiZXhwb3J0cyJdLCJzb3VyY2VzIjpbIi4uLy4uLy4uL3NyYy9BZGFwdGVycy9BdXRoL2ZhY2Vib29rLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogUGFyc2UgU2VydmVyIGF1dGhlbnRpY2F0aW9uIGFkYXB0ZXIgZm9yIEZhY2Vib29rLlxuICpcbiAqIEBjbGFzcyBGYWNlYm9va0FkYXB0ZXJcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIC0gVGhlIGFkYXB0ZXIgY29uZmlndXJhdGlvbiBvcHRpb25zLlxuICogQHBhcmFtIHtzdHJpbmd9IG9wdGlvbnMuYXBwU2VjcmV0IC0gWW91ciBGYWNlYm9vayBBcHAgU2VjcmV0LiBSZXF1aXJlZCBmb3Igc2VjdXJlIGF1dGhlbnRpY2F0aW9uLlxuICogQHBhcmFtIHtzdHJpbmdbXX0gb3B0aW9ucy5hcHBJZHMgLSBBbiBhcnJheSBvZiBGYWNlYm9vayBBcHAgSURzLiBSZXF1aXJlZCBmb3IgdmFsaWRhdGluZyB0aGUgYXBwLlxuICpcbiAqIEBkZXNjcmlwdGlvblxuICogIyMgUGFyc2UgU2VydmVyIENvbmZpZ3VyYXRpb25cbiAqIFRvIGNvbmZpZ3VyZSBQYXJzZSBTZXJ2ZXIgZm9yIEZhY2Vib29rIGF1dGhlbnRpY2F0aW9uLCB1c2UgdGhlIGZvbGxvd2luZyBzdHJ1Y3R1cmU6XG4gKiBgYGBqc29uXG4gKiB7XG4gKiAgIFwiYXV0aFwiOiB7XG4gKiAgICAgXCJmYWNlYm9va1wiOiB7XG4gKiAgICAgICBcImFwcFNlY3JldFwiOiBcInlvdXItYXBwLXNlY3JldFwiLFxuICogICAgICAgXCJhcHBJZHNcIjogW1wieW91ci1hcHAtaWRcIl1cbiAqICAgICB9XG4gKiAgIH1cbiAqIH1cbiAqIGBgYFxuICpcbiAqIFRoZSBhZGFwdGVyIHN1cHBvcnRzIHRoZSBmb2xsb3dpbmcgYXV0aGVudGljYXRpb24gbWV0aG9kczpcbiAqIC0gKipTdGFuZGFyZCBMb2dpbioqOiBSZXF1aXJlcyBgaWRgIGFuZCBgYWNjZXNzX3Rva2VuYC5cbiAqIC0gKipMaW1pdGVkIExvZ2luKio6IFJlcXVpcmVzIGBpZGAgYW5kIGB0b2tlbmAuXG4gKlxuICogIyMgQXV0aCBQYXlsb2Fkc1xuICogIyMjIFN0YW5kYXJkIExvZ2luIFBheWxvYWRcbiAqIGBgYGpzb25cbiAqIHtcbiAqICAgXCJmYWNlYm9va1wiOiB7XG4gKiAgICAgXCJpZFwiOiBcIjEyMzQ1NjdcIixcbiAqICAgICBcImFjY2Vzc190b2tlblwiOiBcImFiYzEyM2RlZjQ1NmdoaTc4OVwiXG4gKiAgIH1cbiAqIH1cbiAqIGBgYFxuICpcbiAqICMjIyBMaW1pdGVkIExvZ2luIFBheWxvYWRcbiAqIGBgYGpzb25cbiAqIHtcbiAqICAgXCJmYWNlYm9va1wiOiB7XG4gKiAgICAgXCJpZFwiOiBcIjEyMzQ1NjdcIixcbiAqICAgICBcInRva2VuXCI6IFwieHh4eHgueXl5eXkuenp6enpcIlxuICogICB9XG4gKiB9XG4gKiBgYGBcbiAqXG4gKiAjIyBOb3Rlc1xuICogLSAqKlN0YW5kYXJkIExvZ2luKio6IFVzZSBgaWRgIGFuZCBgYWNjZXNzX3Rva2VuYCBmb3IgZnVsbCBmdW5jdGlvbmFsaXR5LlxuICogLSAqKkxpbWl0ZWQgTG9naW4qKjogVXNlIGBpZGAgYW5kIGB0b2tlbmAgKEpXVCkgd2hlbiB0cmFja2luZyBpcyBvcHRlZCBvdXQgKGUuZy4sIHZpYSBBcHBsZSdzIEFwcCBUcmFja2luZyBUcmFuc3BhcmVuY3kpLlxuICogLSBTdXBwb3J0ZWQgUGFyc2UgU2VydmVyIHZlcnNpb25zOlxuICogICAtIGA+PSA2LjUuNiA8IDdgXG4gKiAgIC0gYD49IDcuMC4xYFxuICpcbiAqIFNlY3VyZSBhdXRoZW50aWNhdGlvbiBpcyByZWNvbW1lbmRlZCB0byBlbnN1cmUgcHJvcGVyIGRhdGEgcHJvdGVjdGlvbiBhbmQgY29tcGxpYW5jZSB3aXRoIEZhY2Vib29rJ3MgZ3VpZGVsaW5lcy5cbiAqXG4gKiBAc2VlIHtAbGluayBodHRwczovL2RldmVsb3BlcnMuZmFjZWJvb2suY29tL2RvY3MvZmFjZWJvb2stbG9naW4vbGltaXRlZC1sb2dpbi8gRmFjZWJvb2sgTGltaXRlZCBMb2dpbn1cbiAqIEBzZWUge0BsaW5rIGh0dHBzOi8vZGV2ZWxvcGVycy5mYWNlYm9vay5jb20vZG9jcy9mYWNlYm9vay1sb2dpbi9mYWNlYm9vay1sb2dpbi1mb3ItYnVzaW5lc3MvIEZhY2Vib29rIExvZ2luIGZvciBCdXNpbmVzc31cbiAqL1xuXG4vLyBIZWxwZXIgZnVuY3Rpb25zIGZvciBhY2Nlc3NpbmcgdGhlIEZhY2Vib29rIEdyYXBoIEFQSS5cbmNvbnN0IFBhcnNlID0gcmVxdWlyZSgncGFyc2Uvbm9kZScpLlBhcnNlO1xuY29uc3QgY3J5cHRvID0gcmVxdWlyZSgnY3J5cHRvJyk7XG5jb25zdCBqd2tzQ2xpZW50ID0gcmVxdWlyZSgnandrcy1yc2EnKTtcbmNvbnN0IGp3dCA9IHJlcXVpcmUoJ2pzb253ZWJ0b2tlbicpO1xuY29uc3QgaHR0cHNSZXF1ZXN0ID0gcmVxdWlyZSgnLi9odHRwc1JlcXVlc3QnKTtcbmNvbnN0IGF1dGhVdGlscyA9IHJlcXVpcmUoJy4vdXRpbHMnKTtcblxuY29uc3QgVE9LRU5fSVNTVUVSID0gJ2h0dHBzOi8vd3d3LmZhY2Vib29rLmNvbSc7XG5cbmZ1bmN0aW9uIGdldEFwcFNlY3JldFBhdGgoYXV0aERhdGEsIG9wdGlvbnMgPSB7fSkge1xuICBjb25zdCBhcHBTZWNyZXQgPSBvcHRpb25zLmFwcFNlY3JldDtcbiAgaWYgKCFhcHBTZWNyZXQpIHtcbiAgICByZXR1cm4gJyc7XG4gIH1cbiAgY29uc3QgYXBwc2VjcmV0X3Byb29mID0gY3J5cHRvXG4gICAgLmNyZWF0ZUhtYWMoJ3NoYTI1NicsIGFwcFNlY3JldClcbiAgICAudXBkYXRlKGF1dGhEYXRhLmFjY2Vzc190b2tlbilcbiAgICAuZGlnZXN0KCdoZXgnKTtcblxuICByZXR1cm4gYCZhcHBzZWNyZXRfcHJvb2Y9JHthcHBzZWNyZXRfcHJvb2Z9YDtcbn1cblxuZnVuY3Rpb24gdmFsaWRhdGVHcmFwaFRva2VuKGF1dGhEYXRhLCBvcHRpb25zKSB7XG4gIHJldHVybiBncmFwaFJlcXVlc3QoXG4gICAgJ21lP2ZpZWxkcz1pZCZhY2Nlc3NfdG9rZW49JyArIGF1dGhEYXRhLmFjY2Vzc190b2tlbiArIGdldEFwcFNlY3JldFBhdGgoYXV0aERhdGEsIG9wdGlvbnMpXG4gICkudGhlbihkYXRhID0+IHtcbiAgICBpZiAoKGRhdGEgJiYgZGF0YS5pZCA9PSBhdXRoRGF0YS5pZCkgfHwgKHByb2Nlc3MuZW52LlRFU1RJTkcgJiYgYXV0aERhdGEuaWQgPT09ICd0ZXN0JykpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhyb3cgbmV3IFBhcnNlLkVycm9yKFBhcnNlLkVycm9yLk9CSkVDVF9OT1RfRk9VTkQsICdGYWNlYm9vayBhdXRoIGlzIGludmFsaWQgZm9yIHRoaXMgdXNlci4nKTtcbiAgfSk7XG59XG5cbmFzeW5jIGZ1bmN0aW9uIHZhbGlkYXRlR3JhcGhBcHBJZChhcHBJZHMsIGF1dGhEYXRhLCBvcHRpb25zKSB7XG4gIHZhciBhY2Nlc3NfdG9rZW4gPSBhdXRoRGF0YS5hY2Nlc3NfdG9rZW47XG4gIGlmIChwcm9jZXNzLmVudi5URVNUSU5HICYmIGFjY2Vzc190b2tlbiA9PT0gJ3Rlc3QnKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGlmICghQXJyYXkuaXNBcnJheShhcHBJZHMpKSB7XG4gICAgdGhyb3cgbmV3IFBhcnNlLkVycm9yKFBhcnNlLkVycm9yLk9CSkVDVF9OT1RfRk9VTkQsICdhcHBJZHMgbXVzdCBiZSBhbiBhcnJheS4nKTtcbiAgfVxuICBpZiAoIWFwcElkcy5sZW5ndGgpIHtcbiAgICB0aHJvdyBuZXcgUGFyc2UuRXJyb3IoUGFyc2UuRXJyb3IuT0JKRUNUX05PVF9GT1VORCwgJ0ZhY2Vib29rIGF1dGggaXMgbm90IGNvbmZpZ3VyZWQuJyk7XG4gIH1cbiAgY29uc3QgZGF0YSA9IGF3YWl0IGdyYXBoUmVxdWVzdChcbiAgICBgYXBwP2FjY2Vzc190b2tlbj0ke2FjY2Vzc190b2tlbn0ke2dldEFwcFNlY3JldFBhdGgoYXV0aERhdGEsIG9wdGlvbnMpfWBcbiAgKTtcbiAgaWYgKCFkYXRhIHx8ICFhcHBJZHMuaW5jbHVkZXMoZGF0YS5pZCkpIHtcbiAgICB0aHJvdyBuZXcgUGFyc2UuRXJyb3IoUGFyc2UuRXJyb3IuT0JKRUNUX05PVF9GT1VORCwgJ0ZhY2Vib29rIGF1dGggaXMgaW52YWxpZCBmb3IgdGhpcyB1c2VyLicpO1xuICB9XG59XG5cbmNvbnN0IGdldEZhY2Vib29rS2V5QnlLZXlJZCA9IGFzeW5jIChrZXlJZCwgY2FjaGVNYXhFbnRyaWVzLCBjYWNoZU1heEFnZSkgPT4ge1xuICBjb25zdCBjbGllbnQgPSBqd2tzQ2xpZW50KHtcbiAgICBqd2tzVXJpOiBgJHtUT0tFTl9JU1NVRVJ9Ly53ZWxsLWtub3duL29hdXRoL29wZW5pZC9qd2tzL2AsXG4gICAgY2FjaGU6IHRydWUsXG4gICAgY2FjaGVNYXhFbnRyaWVzLFxuICAgIGNhY2hlTWF4QWdlLFxuICB9KTtcblxuICBsZXQga2V5O1xuICB0cnkge1xuICAgIGtleSA9IGF3YWl0IGF1dGhVdGlscy5nZXRTaWduaW5nS2V5KGNsaWVudCwga2V5SWQpO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIHRocm93IG5ldyBQYXJzZS5FcnJvcihcbiAgICAgIFBhcnNlLkVycm9yLk9CSkVDVF9OT1RfRk9VTkQsXG4gICAgICBgVW5hYmxlIHRvIGZpbmQgbWF0Y2hpbmcga2V5IGZvciBLZXkgSUQ6ICR7a2V5SWR9YFxuICAgICk7XG4gIH1cbiAgcmV0dXJuIGtleTtcbn07XG5cbmNvbnN0IHZlcmlmeUlkVG9rZW4gPSBhc3luYyAoeyB0b2tlbiwgaWQgfSwgeyBjbGllbnRJZCwgY2FjaGVNYXhFbnRyaWVzLCBjYWNoZU1heEFnZSB9KSA9PiB7XG4gIGlmICghdG9rZW4pIHtcbiAgICB0aHJvdyBuZXcgUGFyc2UuRXJyb3IoUGFyc2UuRXJyb3IuT0JKRUNUX05PVF9GT1VORCwgJ2lkIHRva2VuIGlzIGludmFsaWQgZm9yIHRoaXMgdXNlci4nKTtcbiAgfVxuXG4gIGNvbnN0IHsga2lkOiBrZXlJZCwgYWxnOiBhbGdvcml0aG0gfSA9IGF1dGhVdGlscy5nZXRIZWFkZXJGcm9tVG9rZW4odG9rZW4pO1xuICBjb25zdCBPTkVfSE9VUl9JTl9NUyA9IDM2MDAwMDA7XG4gIGxldCBqd3RDbGFpbXM7XG5cbiAgY2FjaGVNYXhBZ2UgPSBjYWNoZU1heEFnZSB8fCBPTkVfSE9VUl9JTl9NUztcbiAgY2FjaGVNYXhFbnRyaWVzID0gY2FjaGVNYXhFbnRyaWVzIHx8IDU7XG5cbiAgY29uc3QgZmFjZWJvb2tLZXkgPSBhd2FpdCBnZXRGYWNlYm9va0tleUJ5S2V5SWQoa2V5SWQsIGNhY2hlTWF4RW50cmllcywgY2FjaGVNYXhBZ2UpO1xuICBjb25zdCBzaWduaW5nS2V5ID0gZmFjZWJvb2tLZXkucHVibGljS2V5IHx8IGZhY2Vib29rS2V5LnJzYVB1YmxpY0tleTtcblxuICB0cnkge1xuICAgIGp3dENsYWltcyA9IGp3dC52ZXJpZnkodG9rZW4sIHNpZ25pbmdLZXksIHtcbiAgICAgIGFsZ29yaXRobXM6IGFsZ29yaXRobSxcbiAgICAgIC8vIHRoZSBhdWRpZW5jZSBjYW4gYmUgY2hlY2tlZCBhZ2FpbnN0IGEgc3RyaW5nLCBhIHJlZ3VsYXIgZXhwcmVzc2lvbiBvciBhIGxpc3Qgb2Ygc3RyaW5ncyBhbmQvb3IgcmVndWxhciBleHByZXNzaW9ucy5cbiAgICAgIGF1ZGllbmNlOiBjbGllbnRJZCxcbiAgICB9KTtcbiAgfSBjYXRjaCAoZXhjZXB0aW9uKSB7XG4gICAgY29uc3QgbWVzc2FnZSA9IGV4Y2VwdGlvbi5tZXNzYWdlO1xuXG4gICAgdGhyb3cgbmV3IFBhcnNlLkVycm9yKFBhcnNlLkVycm9yLk9CSkVDVF9OT1RfRk9VTkQsIGAke21lc3NhZ2V9YCk7XG4gIH1cblxuICBpZiAoand0Q2xhaW1zLmlzcyAhPT0gVE9LRU5fSVNTVUVSKSB7XG4gICAgdGhyb3cgbmV3IFBhcnNlLkVycm9yKFxuICAgICAgUGFyc2UuRXJyb3IuT0JKRUNUX05PVF9GT1VORCxcbiAgICAgIGBpZCB0b2tlbiBub3QgaXNzdWVkIGJ5IGNvcnJlY3QgT3BlbklEIHByb3ZpZGVyIC0gZXhwZWN0ZWQ6ICR7VE9LRU5fSVNTVUVSfSB8IGZyb206ICR7and0Q2xhaW1zLmlzc31gXG4gICAgKTtcbiAgfVxuXG4gIGlmIChqd3RDbGFpbXMuc3ViICE9PSBpZCkge1xuICAgIHRocm93IG5ldyBQYXJzZS5FcnJvcihQYXJzZS5FcnJvci5PQkpFQ1RfTk9UX0ZPVU5ELCAnYXV0aCBkYXRhIGlzIGludmFsaWQgZm9yIHRoaXMgdXNlci4nKTtcbiAgfVxuICByZXR1cm4gand0Q2xhaW1zO1xufTtcblxuLy8gUmV0dXJucyBhIHByb21pc2UgdGhhdCBmdWxmaWxscyBpZmYgdGhpcyB1c2VyIGlkIGlzIHZhbGlkLlxuZnVuY3Rpb24gdmFsaWRhdGVBdXRoRGF0YShhdXRoRGF0YSwgb3B0aW9ucykge1xuICBpZiAoYXV0aERhdGEudG9rZW4pIHtcbiAgICByZXR1cm4gdmVyaWZ5SWRUb2tlbihhdXRoRGF0YSwgb3B0aW9ucyk7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHZhbGlkYXRlR3JhcGhUb2tlbihhdXRoRGF0YSwgb3B0aW9ucyk7XG4gIH1cbn1cblxuLy8gUmV0dXJucyBhIHByb21pc2UgdGhhdCBmdWxmaWxscyBpZmYgdGhpcyBhcHAgaWQgaXMgdmFsaWQuXG5mdW5jdGlvbiB2YWxpZGF0ZUFwcElkKGFwcElkcywgYXV0aERhdGEsIG9wdGlvbnMpIHtcbiAgaWYgKGF1dGhEYXRhLnRva2VuKSB7XG4gICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiB2YWxpZGF0ZUdyYXBoQXBwSWQoYXBwSWRzLCBhdXRoRGF0YSwgb3B0aW9ucyk7XG4gIH1cbn1cblxuLy8gQSBwcm9taXNleSB3cmFwcGVyIGZvciBGQiBncmFwaCByZXF1ZXN0cy5cbmZ1bmN0aW9uIGdyYXBoUmVxdWVzdChwYXRoKSB7XG4gIHJldHVybiBodHRwc1JlcXVlc3QuZ2V0KCdodHRwczovL2dyYXBoLmZhY2Vib29rLmNvbS8nICsgcGF0aCk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICB2YWxpZGF0ZUFwcElkOiB2YWxpZGF0ZUFw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
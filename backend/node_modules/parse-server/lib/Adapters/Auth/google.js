/**
 * Parse Server authentication adapter for Google.
 *
 * @class GoogleAdapter
 * @param {Object} options - The adapter configuration options.
 * @param {string} options.clientId - Your Google application Client ID. Required for authentication.
 *
 * @description
 * ## Parse Server Configuration
 * To configure Parse Server for Google authentication, use the following structure:
 * ```json
 * {
 *   "auth": {
 *     "google": {
 *       "clientId": "your-client-id"
 *     }
 *   }
 * }
 * ```
 *
 * The adapter requires the following `authData` fields:
 * - **id**: The Google user ID.
 * - **id_token**: The Google ID token.
 * - **access_token**: The Google access token.
 *
 * ## Auth Payload
 * ### Example Auth Data Payload
 * ```json
 * {
 *   "google": {
 *     "id": "1234567",
 *     "id_token": "xxxxx.yyyyy.zzzzz",
 *     "access_token": "abc123def456ghi789"
 *   }
 * }
 * ```
 *
 * ## Notes
 * - Ensure your Google Client ID is configured properly in the Parse Server configuration.
 * - The `id_token` and `access_token` are validated against Google's authentication services.
 *
 * @see {@link https://developers.google.com/identity/sign-in/web/backend-auth Google Authentication Documentation}
 */

'use strict';

// Helper functions for accessing the google API.
var Parse = require('parse/node').Parse;
const https = require('https');
const jwt = require('jsonwebtoken');
const authUtils = require('./utils');
const TOKEN_ISSUER = 'accounts.google.com';
const HTTPS_TOKEN_ISSUER = 'https://accounts.google.com';
let cache = {};

// Retrieve Google Signin Keys (with cache control)
function getGoogleKeyByKeyId(keyId) {
  if (cache[keyId] && cache.expiresAt > new Date()) {
    return cache[keyId];
  }
  return new Promise((resolve, reject) => {
    https.get(`https://www.googleapis.com/oauth2/v3/certs`, res => {
      let data = '';
      res.on('data', chunk => {
        data += chunk.toString('utf8');
      });
      res.on('end', () => {
        const {
          keys
        } = JSON.parse(data);
        const pems = keys.reduce((pems, {
          n: modulus,
          e: exposant,
          kid
        }) => Object.assign(pems, {
          [kid]: rsaPublicKeyToPEM(modulus, exposant)
        }), {});
        if (res.headers['cache-control']) {
          var expire = res.headers['cache-control'].match(/max-age=([0-9]+)/);
          if (expire) {
            cache = Object.assign({}, pems, {
              expiresAt: new Date(new Date().getTime() + Number(expire[1]) * 1000)
            });
          }
        }
        resolve(pems[keyId]);
      });
    }).on('error', reject);
  });
}
async function verifyIdToken({
  id_token: token,
  id
}, {
  clientId
}) {
  if (!token) {
    throw new Parse.Error(Parse.Error.OBJECT_NOT_FOUND, `id token is invalid for this user.`);
  }
  const {
    kid: keyId,
    alg: algorithm
  } = authUtils.getHeaderFromToken(token);
  let jwtClaims;
  const googleKey = await getGoogleKeyByKeyId(keyId);
  try {
    jwtClaims = jwt.verify(token, googleKey, {
      algorithms: algorithm,
      audience: clientId
    });
  } catch (exception) {
    const message = exception.message;
    throw new Parse.Error(Parse.Error.OBJECT_NOT_FOUND, `${message}`);
  }
  if (jwtClaims.iss !== TOKEN_ISSUER && jwtClaims.iss !== HTTPS_TOKEN_ISSUER) {
    throw new Parse.Error(Parse.Error.OBJECT_NOT_FOUND, `id token not issued by correct provider - expected: ${TOKEN_ISSUER} or ${HTTPS_TOKEN_ISSUER} | from: ${jwtClaims.iss}`);
  }
  if (jwtClaims.sub !== id) {
    throw new Parse.Error(Parse.Error.OBJECT_NOT_FOUND, `auth data is invalid for this user.`);
  }
  if (clientId && jwtClaims.aud !== clientId) {
    throw new Parse.Error(Parse.Error.OBJECT_NOT_FOUND, `id token not authorized for this clientId.`);
  }
  return jwtClaims;
}

// Returns a promise that fulfills if this user id is valid.
function validateAuthData(authData, options = {}) {
  return verifyIdToken(authData, options);
}

// Returns a promise that fulfills if this app id is valid.
function validateAppId() {
  return Promise.resolve();
}
module.exports = {
  validateAppId: validateAppId,
  validateAuthData: validateAuthData
};

// Helpers functions to convert the RSA certs to PEM (from jwks-rsa)
function rsaPublicKeyToPEM(modulusB64, exponentB64) {
  const modulus = new Buffer(modulusB64, 'base64');
  const exponent = new Buffer(exponentB64, 'base64');
  const modulusHex = prepadSigned(modulus.toString('hex'));
  const exponentHex = prepadSigned(exponent.toString('hex'));
  const modlen = modulusHex.length / 2;
  const explen = exponentHex.length / 2;
  const encodedModlen = encodeLengthHex(modlen);
  const encodedExplen = encodeLengthHex(explen);
  const encodedPubkey = '30' + encodeLengthHex(modlen + explen + encodedModlen.length / 2 + encodedExplen.length / 2 + 2) + '02' + encodedModlen + modulusHex + '02' + encodedExplen + exponentHex;
  const der = new Buffer(encodedPubkey, 'hex').toString('base64');
  let pem = '-----BEGIN RSA PUBLIC KEY-----\n';
  pem += `${der.match(/.{1,64}/g).join('\n')}`;
  pem += '\n-----END RSA PUBLIC KEY-----\n';
  return pem;
}
function prepadSigned(hexStr) {
  const msb = hexStr[0];
  if (msb < '0' || msb > '7') {
    return `00${hexStr}`;
  }
  return hexStr;
}
function toHex(number) {
  const nstr = number.toString(16);
  if (nstr.length % 2) {
    return `0${nstr}`;
  }
  return nstr;
}
function encodeLengthHex(n) {
  if (n <= 127) {
    return toHex(n);
  }
  const nHex = toHex(n);
  const lengthOfLengthByte = 128 + nHex.length / 2;
  return toHex(lengthOfLengthByte) + nHex;
}
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJuYW1lcyI6WyJQYXJzZSIsInJlcXVpcmUiLCJodHRwcyIsImp3dCIsImF1dGhVdGlscyIsIlRPS0VOX0lTU1VFUiIsIkhUVFBTX1RPS0VOX0lTU1VFUiIsImNhY2hlIiwiZ2V0R29vZ2xlS2V5QnlLZXlJZCIsImtleUlkIiwiZXhwaXJlc0F0IiwiRGF0ZSIsIlByb21pc2UiLCJyZXNvbHZlIiwicmVqZWN0IiwiZ2V0IiwicmVzIiwiZGF0YSIsIm9uIiwiY2h1bmsiLCJ0b1N0cmluZyIsImtleXMiLCJKU09OIiwicGFyc2UiLCJwZW1zIiwicmVkdWNlIiwibiIsIm1vZHVsdXMiLCJlIiwiZXhwb3NhbnQiLCJraWQiLCJPYmplY3QiLCJhc3NpZ24iLCJyc2FQdWJsaWNLZXlUb1BFTSIsImhlYWRlcnMiLCJleHBpcmUiLCJtYXRjaCIsImdldFRpbWUiLCJOdW1iZXIiLCJ2ZXJpZnlJZFRva2VuIiwiaWRfdG9rZW4iLCJ0b2tlbiIsImlkIiwiY2xpZW50SWQiLCJFcnJvciIsIk9CSkVDVF9OT1RfRk9VTkQiLCJhbGciLCJhbGdvcml0aG0iLCJnZXRIZWFkZXJGcm9tVG9rZW4iLCJqd3RDbGFpbXMiLCJnb29nbGVLZXkiLCJ2ZXJpZnkiLCJhbGdvcml0aG1zIiwiYXVkaWVuY2UiLCJleGNlcHRpb24iLCJtZXNzYWdlIiwiaXNzIiwic3ViIiwiYXVkIiwidmFsaWRhdGVBdXRoRGF0YSIsImF1dGhEYXRhIiwib3B0aW9ucyIsInZhbGlkYXRlQXBwSWQiLCJtb2R1bGUiLCJleHBvcnRzIiwibW9kdWx1c0I2NCIsImV4cG9uZW50QjY0IiwiQnVmZmVyIiwiZXhwb25lbnQiLCJtb2R1bHVzSGV4IiwicHJlcGFkU2lnbmVkIiwiZXhwb25lbnRIZXgiLCJtb2RsZW4iLCJsZW5ndGgiLCJleHBsZW4iLCJlbmNvZGVkTW9kbGVuIiwiZW5jb2RlTGVuZ3RoSGV4IiwiZW5jb2RlZEV4cGxlbiIsImVuY29kZWRQdWJrZXkiLCJkZXIiLCJwZW0iLCJqb2luIiwiaGV4U3RyIiwibXNiIiwidG9IZXgiLCJudW1iZXIiLCJuc3RyIiwibkhleCIsImxlbmd0aE9mTGVuZ3RoQnl0ZSJdLCJzb3VyY2VzIjpbIi4uLy4uLy4uL3NyYy9BZGFwdGVycy9BdXRoL2dvb2dsZS5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIFBhcnNlIFNlcnZlciBhdXRoZW50aWNhdGlvbiBhZGFwdGVyIGZvciBHb29nbGUuXG4gKlxuICogQGNsYXNzIEdvb2dsZUFkYXB0ZXJcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIC0gVGhlIGFkYXB0ZXIgY29uZmlndXJhdGlvbiBvcHRpb25zLlxuICogQHBhcmFtIHtzdHJpbmd9IG9wdGlvbnMuY2xpZW50SWQgLSBZb3VyIEdvb2dsZSBhcHBsaWNhdGlvbiBDbGllbnQgSUQuIFJlcXVpcmVkIGZvciBhdXRoZW50aWNhdGlvbi5cbiAqXG4gKiBAZGVzY3JpcHRpb25cbiAqICMjIFBhcnNlIFNlcnZlciBDb25maWd1cmF0aW9uXG4gKiBUbyBjb25maWd1cmUgUGFyc2UgU2VydmVyIGZvciBHb29nbGUgYXV0aGVudGljYXRpb24sIHVzZSB0aGUgZm9sbG93aW5nIHN0cnVjdHVyZTpcbiAqIGBgYGpzb25cbiAqIHtcbiAqICAgXCJhdXRoXCI6IHtcbiAqICAgICBcImdvb2dsZVwiOiB7XG4gKiAgICAgICBcImNsaWVudElkXCI6IFwieW91ci1jbGllbnQtaWRcIlxuICogICAgIH1cbiAqICAgfVxuICogfVxuICogYGBgXG4gKlxuICogVGhlIGFkYXB0ZXIgcmVxdWlyZXMgdGhlIGZvbGxvd2luZyBgYXV0aERhdGFgIGZpZWxkczpcbiAqIC0gKippZCoqOiBUaGUgR29vZ2xlIHVzZXIgSUQuXG4gKiAtICoqaWRfdG9rZW4qKjogVGhlIEdvb2dsZSBJRCB0b2tlbi5cbiAqIC0gKiphY2Nlc3NfdG9rZW4qKjogVGhlIEdvb2dsZSBhY2Nlc3MgdG9rZW4uXG4gKlxuICogIyMgQXV0aCBQYXlsb2FkXG4gKiAjIyMgRXhhbXBsZSBBdXRoIERhdGEgUGF5bG9hZFxuICogYGBganNvblxuICoge1xuICogICBcImdvb2dsZVwiOiB7XG4gKiAgICAgXCJpZFwiOiBcIjEyMzQ1NjdcIixcbiAqICAgICBcImlkX3Rva2VuXCI6IFwieHh4eHgueXl5eXkuenp6enpcIixcbiAqICAgICBcImFjY2Vzc190b2tlblwiOiBcImFiYzEyM2RlZjQ1NmdoaTc4OVwiXG4gKiAgIH1cbiAqIH1cbiAqIGBgYFxuICpcbiAqICMjIE5vdGVzXG4gKiAtIEVuc3VyZSB5b3VyIEdvb2dsZSBDbGllbnQgSUQgaXMgY29uZmlndXJlZCBwcm9wZXJseSBpbiB0aGUgUGFyc2UgU2VydmVyIGNvbmZpZ3VyYXRpb24uXG4gKiAtIFRoZSBgaWRfdG9rZW5gIGFuZCBgYWNjZXNzX3Rva2VuYCBhcmUgdmFsaWRhdGVkIGFnYWluc3QgR29vZ2xlJ3MgYXV0aGVudGljYXRpb24gc2VydmljZXMuXG4gKlxuICogQHNlZSB7QGxpbmsgaHR0cHM6Ly9kZXZlbG9wZXJzLmdvb2dsZS5jb20vaWRlbnRpdHkvc2lnbi1pbi93ZWIvYmFja2VuZC1hdXRoIEdvb2dsZSBBdXRoZW50aWNhdGlvbiBEb2N1bWVudGF0aW9ufVxuICovXG5cbid1c2Ugc3RyaWN0JztcblxuLy8gSGVscGVyIGZ1bmN0aW9ucyBmb3IgYWNjZXNzaW5nIHRoZSBnb29nbGUgQVBJLlxudmFyIFBhcnNlID0gcmVxdWlyZSgncGFyc2Uvbm9kZScpLlBhcnNlO1xuXG5jb25zdCBodHRwcyA9IHJlcXVpcmUoJ2h0dHBzJyk7XG5jb25zdCBqd3QgPSByZXF1aXJlKCdqc29ud2VidG9rZW4nKTtcbmNvbnN0IGF1dGhVdGlscyA9IHJlcXVpcmUoJy4vdXRpbHMnKTtcblxuY29uc3QgVE9LRU5fSVNTVUVSID0gJ2FjY291bnRzLmdvb2dsZS5jb20nO1xuY29uc3QgSFRUUFNfVE9LRU5fSVNTVUVSID0gJ2h0dHBzOi8vYWNjb3VudHMuZ29vZ2xlLmNvbSc7XG5cbmxldCBjYWNoZSA9IHt9O1xuXG4vLyBSZXRyaWV2ZSBHb29nbGUgU2lnbmluIEtleXMgKHdpdGggY2FjaGUgY29udHJvbClcbmZ1bmN0aW9uIGdldEdvb2dsZUtleUJ5S2V5SWQoa2V5SWQpIHtcbiAgaWYgKGNhY2hlW2tleUlkXSAmJiBjYWNoZS5leHBpcmVzQXQgPiBuZXcgRGF0ZSgpKSB7XG4gICAgcmV0dXJuIGNhY2hlW2tleUlkXTtcbiAgfVxuXG4gIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgaHR0cHNcbiAgICAgIC5nZXQoYGh0dHBzOi8vd3d3Lmdvb2dsZWFwaXMuY29tL29hdXRoMi92My9jZXJ0c2AsIHJlcyA9PiB7XG4gICAgICAgIGxldCBkYXRhID0gJyc7XG4gICAgICAgIHJlcy5vbignZGF0YScsIGNodW5rID0+IHtcbiAgICAgICAgICBkYXRhICs9IGNodW5rLnRvU3RyaW5nKCd1dGY4Jyk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXMub24oJ2VuZCcsICgpID0+IHtcbiAgICAgICAgICBjb25zdCB7IGtleXMgfSA9IEpTT04ucGFyc2UoZGF0YSk7XG4gICAgICAgICAgY29uc3QgcGVtcyA9IGtleXMucmVkdWNlKFxuICAgICAgICAgICAgKHBlbXMsIHsgbjogbW9kdWx1cywgZTogZXhwb3NhbnQsIGtpZCB9KSA9PlxuICAgICAgICAgICAgICBPYmplY3QuYXNzaWduKHBlbXMsIHtcbiAgICAgICAgICAgICAgICBba2lkXTogcnNhUHVibGljS2V5VG9QRU0obW9kdWx1cywgZXhwb3NhbnQpLFxuICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgIHt9XG4gICAgICAgICAgKTtcblxuICAgICAgICAgIGlmIChyZXMuaGVhZGVyc1snY2FjaGUtY29udHJvbCddKSB7XG4gICAgICAgICAgICB2YXIgZXhwaXJlID0gcmVzLmhlYWRlcnNbJ2NhY2hlLWNvbnRyb2wnXS5tYXRjaCgvbWF4LWFnZT0oWzAtOV0rKS8pO1xuXG4gICAgICAgICAgICBpZiAoZXhwaXJlKSB7XG4gICAgICAgICAgICAgIGNhY2hlID0gT2JqZWN0LmFzc2lnbih7fSwgcGVtcywge1xuICAgICAgICAgICAgICAgIGV4cGlyZXNBdDogbmV3IERhdGUobmV3IERhdGUoKS5nZXRUaW1lKCkgKyBOdW1iZXIoZXhwaXJlWzFdKSAqIDEwMDApLFxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXNvbHZlKHBlbXNba2V5SWRdKTtcbiAgICAgICAgfSk7XG4gICAgICB9KVxuICAgICAgLm9uKCdlcnJvcicsIHJlamVjdCk7XG4gIH0pO1xufVxuXG5hc3luYyBmdW5jdGlvbiB2ZXJpZnlJZFRva2VuKHsgaWRfdG9rZW46IHRva2VuLCBpZCB9LCB7IGNsaWVudElkIH0pIHtcbiAgaWYgKCF0b2tlbikge1xuICAgIHRocm93IG5ldyBQYXJzZS5FcnJvcihQYXJzZS5FcnJvci5PQkpFQ1RfTk9UX0ZPVU5ELCBgaWQgdG9rZW4gaXMgaW52YWxpZCBmb3IgdGhpcyB1c2VyLmApO1xuICB9XG5cbiAgY29uc3QgeyBraWQ6IGtleUlkLCBhbGc6IGFsZ29yaXRobSB9ID0gYXV0aFV0aWxzLmdldEhlYWRlckZyb21Ub2tlbih0b2tlbik7XG4gIGxldCBqd3RDbGFpbXM7XG4gIGNvbnN0IGdvb2dsZUtleSA9IGF3YWl0IGdldEdvb2dsZUtleUJ5S2V5SWQoa2V5SWQpO1xuXG4gIHRyeSB7XG4gICAgand0Q2xhaW1zID0gand0LnZlcmlmeSh0b2tlbiwgZ29vZ2xlS2V5LCB7XG4gICAgICBhbGdvcml0aG1zOiBhbGdvcml0aG0sXG4gICAgICBhdWRpZW5jZTogY2xpZW50SWQsXG4gICAgfSk7XG4gIH0gY2F0Y2ggKGV4Y2VwdGlvbikge1xuICAgIGNvbnN0IG1lc3NhZ2UgPSBleGNlcHRpb24ubWVzc2FnZTtcbiAgICB0aHJvdyBuZXcgUGFyc2UuRXJyb3IoUGFyc2UuRXJyb3IuT0JKRUNUX05PVF9GT1VORCwgYCR7bWVzc2FnZX1gKTtcbiAgfVxuXG4gIGlmIChqd3RDbGFpbXMuaXNzICE9PSBUT0tFTl9JU1NVRVIgJiYgand0Q2xhaW1zLmlzcyAhPT0gSFRUUFNfVE9LRU5fSVNTVUVSKSB7XG4gICAgdGhyb3cgbmV3IFBhcnNlLkVycm9yKFxuICAgICAgUGFyc2UuRXJyb3IuT0JKRUNUX05PVF9GT1VORCxcbiAgICAgIGBpZCB0b2tlbiBub3QgaXNzdWVkIGJ5IGNvcnJlY3QgcHJvdmlkZXIgLSBleHBlY3RlZDogJHtUT0tFTl9JU1NVRVJ9IG9yICR7SFRUUFNfVE9LRU5fSVNTVUVSfSB8IGZyb206ICR7and0Q2xhaW1zLmlzc31gXG4gICAgKTtcbiAgfVxuXG4gIGlmIChqd3RDbGFpbXMuc3ViICE9PSBpZCkge1xuICAgIHRocm93IG5ldyBQYXJzZS5FcnJvcihQYXJzZS5FcnJvci5PQkpFQ1RfTk9UX0ZPVU5ELCBgYXV0aCBkYXRhIGlzIGludmFsaWQgZm9yIHRoaXMgdXNlci5gKTtcbiAgfVxuXG4gIGlmIChjbGllbnRJZCAmJiBqd3RDbGFpbXMuYXVkICE9PSBjbGllbnRJZCkge1xuICAgIHRocm93IG5ldyBQYXJzZS5FcnJvcihcbiAgICAgIFBhcnNlLkVycm9yLk9CSkVDVF9OT1RfRk9VTkQsXG4gICAgICBgaWQgdG9rZW4gbm90IGF1dGhvcml6ZWQgZm9yIHRoaXMgY2xpZW50SWQuYFxuICAgICk7XG4gIH1cblxuICByZXR1cm4gand0Q2xhaW1zO1xufVxuXG4vLyBSZXR1cm5zIGEgcHJvbWlzZSB0aGF0IGZ1bGZpbGxzIGlmIHRoaXMgdXNlciBpZCBpcyB2YWxpZC5cbmZ1bmN0aW9uIHZhbGlkYXRlQXV0aERhdGEoYXV0aERhdGEsIG9wdGlvbnMgPSB7fSkge1xuICByZXR1cm4gdmVyaWZ5SWRUb2tlbihhdXRoRGF0YSwgb3B0aW9ucyk7XG59XG5cbi8vIFJldHVybnMgYSBwcm9taXNlIHRoYXQgZnVsZmlsbHMgaWYgdGhpcyBhcHAgaWQgaXMgdmFsaWQuXG5mdW5jdGlvbiB2YWxpZGF0ZUFwcElkKCkge1xuICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICB2YWxpZGF0ZUFwcElkOiB2YWxpZGF0ZUFwcElkLFxuICB2YWxpZGF0ZUF1dGhEYXRhOiB2YWxpZGF0ZUF1dGhEYXRhLFxufTtcblxuLy8gSGVscGVycyBmdW5jdGlvbnMgdG8gY29udmVydCB0aGUgUlNBIGNlcnRzIHRvIFBFTSAoZnJvbSBqd2tzLXJzYSlcbmZ1bmN0aW9uIHJzYVB1YmxpY0tleVRvUEVNKG1vZHVsdXNCNjQsIGV4cG9uZW50QjY0KSB7XG4gIGNvbnN0IG1vZHVsdXMgPSBuZXcgQnVmZmVyKG1vZHVsdXNCNjQsICdiYXNlNjQnKTtcbiAgY29uc3QgZXhwb25lbnQgPSBuZXcgQnVmZmVyKGV4cG9uZW50QjY0LCAnYmFzZTY0Jyk7XG4gIGNvbnN0IG1vZHVsdXNIZXggPSBwcmVwYWRTaWduZWQobW9kdWx1cy50b1N0cmluZygnaGV4JykpO1xuICBjb25zdCBleHBvbmVudEhleCA9IHByZXBhZFNpZ25lZChleHBvbmVudC50b1N0cmluZygnaGV4JykpO1xuICBjb25zdCBtb2RsZW4gPSBtb2R1bHVzSGV4Lmxlbmd0aCAvIDI7XG4gIGNvbnN0IGV4cGxlbiA9IGV4cG9uZW50SGV4Lmxlbmd0aCAvIDI7XG5cbiAgY29uc3QgZW5jb2RlZE1vZGxlbiA9IGVuY29kZUxlbmd0aEhleChtb2RsZW4pO1xuICBjb25zdCBlbmNvZGVkRXhwbGVuID0gZW5jb2RlTGVuZ3RoSGV4KGV4cGxlbik7XG4gIGNvbnN0IGVuY29kZWRQdWJrZXkgPVxuICAgICczMCcgK1xuICAgIGVuY29kZUxlbmd0aEhleChtb2RsZW4gKyBleHBsZW4gKyBlbmNvZGVkTW9kbGVuLmxlbmd0aCAvIDIgKyBlbmNvZGVkRXhwbGVuLmxlbmd0aCAvIDIgKyAyKSArXG4gICAgJzAyJyArXG4gICAgZW5jb2RlZE1vZGxlbiArXG4gICAgbW9kdWx1c0hleCArXG4gICAgJzAyJyArXG4gICAgZW5jb2RlZEV4cGxlbiArXG4gICAgZXhwb25lbnRIZXg7XG5cbiAgY29uc3QgZGVyID0gbmV3IEJ1ZmZlcihlbmNvZGVkUHVia2V5LCAnaGV4JykudG9TdHJpbmcoJ2Jhc2U2NCcpO1xuXG4gIGxldCBwZW0gPSAnLS0tLS1CRUdJTiBSU0EgUFVCTElDIEtFWS0tLS0tXFxuJztcbiAgcGVtICs9IGAke2Rlci5tYXRjaCgvLnsxLDY0fS9nKS5qb2luKCdcXG4nKX1gO1xuICBwZW0gKz0gJ1xcbi0tLS0tRU5EIFJTQSBQVUJMSUMgS0VZLS0tLS1cXG4nO1xuICByZXR1cm4gcGVtO1xufVxuXG5mdW5jdGlvbiBwcmVwYWRTaWduZWQoaGV4U3RyKSB7XG4gIGNvbnN0IG1zYiA9IGhleFN0clswXTtcbiAgaWYgKG1zYiA8ICcwJyB8fCBtc2IgPiAnNycpIHtcbiAgICByZXR1cm4gYDAwJHtoZXhTdHJ9YDtcbiAgfVxuICByZXR1cm4gaGV4U3RyO1xufVxuXG5mdW5jdGlvbiB0b0hleChudW1iZXIpIHtcbiAgY29uc3QgbnN0ciA9IG51bWJlci50b1N0cmluZygxNik7XG4gIGlmIChuc3RyLmxlbmd0aCAlIDIpIHtcbiAgICByZXR1cm4gYDAke25zdHJ9YDtcbiAgfVxuICByZXR1cm4gbnN0cjtcbn1cblxuZnVuY3Rpb24gZW5jb2RlTGVuZ3RoSGV4KG4pIHtcbiAgaWYgKG4gPD0gMTI3KSB7XG4gICAgcmV0dXJuIHRvSGV4KG4pO1xuICB9XG4gIGNvbnN0IG5IZXggPSB0b0hleChuKTtcbiAgY29uc3QgbGVuZ3RoT2ZMZW5ndGhCeXRlID0gMTI4ICsgbkhleC5sZW5ndGggLyAyO1xuICByZXR1cm4gdG9IZXgobGVuZ3RoT2ZMZW5ndGhCeXRlKSArIG5IZXg7XG59XG4iXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztB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QUFDSixNQUFNLEdBQUdFLE1BQU0sR0FBR0MsYUFBYSxDQUFDRixNQUFNLEdBQUcsQ0FBQyxHQUFHSSxhQUFhLENBQUNKLE1BQU0sR0FBRyxDQUFDLEdBQUcsQ0FBQyxDQUFDLEdBQzFGLElBQUksR0FDSkUsYUFBYSxHQUNiTixVQUFVLEdBQ1YsSUFBSSxHQUNKUSxhQUFhLEdBQ2JOLFdBQVc7RUFFYixNQUFNUSxHQUFHLEdBQUcsSUFBSVosTUFBTSxDQUFDVyxhQUFhLEVBQUUsS0FBSyxDQUFDLENBQUMxRCxRQUFRLENBQUMsUUFBUSxDQUFDO0VBRS9ELElBQUk0RCxHQUFHLEdBQUcsa0NBQWtDO0VBQzVDQSxHQUFHLElBQUksR0FBR0QsR0FBRyxDQUFDM0MsS0FBSyxDQUFDLFVBQVUsQ0FBQyxDQUFDNkMsSUFBSSxDQUFDLElBQUksQ0FBQyxFQUFFO0VBQzVDRCxHQUFHLElBQUksa0NBQWtDO0VBQ3pDLE9BQU9BLEdBQUc7QUFDWjtBQUVBLFNBQVNWLFlBQVlBLENBQUNZLE1BQU0sRUFBRTtFQUM1QixNQUFNQyxHQUFHLEdBQUdELE1BQU0sQ0FBQyxDQUFDLENBQUM7RUFDckIsSUFBSUMsR0FBRyxHQUFHLEdBQUcsSUFBSUEsR0FBRyxHQUFHLEdBQUcsRUFBRTtJQUMxQixPQUFPLEtBQUtELE1BQU0sRUFBRTtFQUN0QjtFQUNBLE9BQU9BLE1BQU07QUFDZjtBQUVBLFNBQVNFLEtBQUtBLENBQUNDLE1BQU0sRUFBRTtFQUNyQixNQUFNQyxJQUFJLEdBQUdELE1BQU0sQ0FBQ2pFLFFBQVEsQ0FBQyxFQUFFLENBQUM7RUFDaEMsSUFBSWtFLElBQUksQ0FBQ2IsTUFBTSxHQUFHLENBQUMsRUFBRTtJQUNuQixPQUFPLElBQUlhLElBQUksRUFBRTtFQUNuQjtFQUNBLE9BQU9BLElBQUk7QUFDYjtBQUVBLFNBQVNWLGVBQWVBLENBQUNsRCxDQUFDLEVBQUU7RUFDMUIsSUFBSUEsQ0FBQyxJQUFJLEdBQUcsRUFBRTtJQUNaLE9BQU8wRCxLQUFLLENBQUMxRCxDQUFDLENBQUM7RUFDakI7RUFDQSxNQUFNNkQsSUFBSSxHQUFHSCxLQUFLLENBQUMxRCxDQUFDLENBQUM7RUFDckIsTUFBTThELGtCQUFrQixHQUFHLEdBQUcsR0FBR0QsSUFBSSxDQUFDZCxNQUFNLEdBQUcsQ0FBQztFQUNoRCxPQUFPVyxLQUFLLENBQUNJLGtCQUFrQixDQUFDLEdBQUdELElBQUk7QUFDekMiLCJpZ25vcmVMaXN0IjpbXX0=
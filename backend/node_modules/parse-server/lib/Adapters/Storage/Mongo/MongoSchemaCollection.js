"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _MongoCollection = _interopRequireDefault(require("./MongoCollection"));
var _node = _interopRequireDefault(require("parse/node"));
function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }
function mongoFieldToParseSchemaField(type) {
  if (type[0] === '*') {
    return {
      type: 'Pointer',
      targetClass: type.slice(1)
    };
  }
  if (type.startsWith('relation<')) {
    return {
      type: 'Relation',
      targetClass: type.slice('relation<'.length, type.length - 1)
    };
  }
  switch (type) {
    case 'number':
      return {
        type: 'Number'
      };
    case 'string':
      return {
        type: 'String'
      };
    case 'boolean':
      return {
        type: 'Boolean'
      };
    case 'date':
      return {
        type: 'Date'
      };
    case 'map':
    case 'object':
      return {
        type: 'Object'
      };
    case 'array':
      return {
        type: 'Array'
      };
    case 'geopoint':
      return {
        type: 'GeoPoint'
      };
    case 'file':
      return {
        type: 'File'
      };
    case 'bytes':
      return {
        type: 'Bytes'
      };
    case 'polygon':
      return {
        type: 'Polygon'
      };
  }
}
const nonFieldSchemaKeys = ['_id', '_metadata', '_client_permissions'];
function mongoSchemaFieldsToParseSchemaFields(schema) {
  var fieldNames = Object.keys(schema).filter(key => nonFieldSchemaKeys.indexOf(key) === -1);
  var response = fieldNames.reduce((obj, fieldName) => {
    obj[fieldName] = mongoFieldToParseSchemaField(schema[fieldName]);
    if (schema._metadata && schema._metadata.fields_options && schema._metadata.fields_options[fieldName]) {
      obj[fieldName] = Object.assign({}, obj[fieldName], schema._metadata.fields_options[fieldName]);
    }
    return obj;
  }, {});
  response.ACL = {
    type: 'ACL'
  };
  response.createdAt = {
    type: 'Date'
  };
  response.updatedAt = {
    type: 'Date'
  };
  response.objectId = {
    type: 'String'
  };
  return response;
}
const emptyCLPS = Object.freeze({
  find: {},
  count: {},
  get: {},
  create: {},
  update: {},
  delete: {},
  addField: {},
  protectedFields: {}
});
const defaultCLPS = Object.freeze({
  ACL: {
    '*': {
      read: true,
      write: true
    }
  },
  find: {
    '*': true
  },
  count: {
    '*': true
  },
  get: {
    '*': true
  },
  create: {
    '*': true
  },
  update: {
    '*': true
  },
  delete: {
    '*': true
  },
  addField: {
    '*': true
  },
  protectedFields: {
    '*': []
  }
});
function mongoSchemaToParseSchema(mongoSchema) {
  let clps = defaultCLPS;
  let indexes = {};
  if (mongoSchema._metadata) {
    if (mongoSchema._metadata.class_permissions) {
      clps = {
        ...emptyCLPS,
        ...mongoSchema._metadata.class_permissions
      };
    }
    if (mongoSchema._metadata.indexes) {
      indexes = {
        ...mongoSchema._metadata.indexes
      };
    }
  }
  return {
    className: mongoSchema._id,
    fields: mongoSchemaFieldsToParseSchemaFields(mongoSchema),
    classLevelPermissions: clps,
    indexes: indexes
  };
}
function _mongoSchemaQueryFromNameQuery(name, query) {
  const object = {
    _id: name
  };
  if (query) {
    Object.keys(query).forEach(key => {
      object[key] = query[key];
    });
  }
  return object;
}

// Returns a type suitable for inserting into mongo _SCHEMA collection.
// Does no validation. That is expected to be done in Parse Server.
function parseFieldTypeToMongoFieldType({
  type,
  targetClass
}) {
  switch (type) {
    case 'Pointer':
      return `*${targetClass}`;
    case 'Relation':
      return `relation<${targetClass}>`;
    case 'Number':
      return 'number';
    case 'String':
      return 'string';
    case 'Boolean':
      return 'boolean';
    case 'Date':
      return 'date';
    case 'Object':
      return 'object';
    case 'Array':
      return 'array';
    case 'GeoPoint':
      return 'geopoint';
    case 'File':
      return 'file';
    case 'Bytes':
      return 'bytes';
    case 'Polygon':
      return 'polygon';
  }
}
class MongoSchemaCollection {
  constructor(collection) {
    this._collection = collection;
  }
  _fetchAllSchemasFrom_SCHEMA() {
    return this._collection._rawFind({}).then(schemas => schemas.map(mongoSchemaToParseSchema));
  }
  _fetchOneSchemaFrom_SCHEMA(name) {
    return this._collection._rawFind(_mongoSchemaQueryFromNameQuery(name), {
      limit: 1
    }).then(results => {
      if (results.length === 1) {
        return mongoSchemaToParseSchema(results[0]);
      } else {
        throw undefined;
      }
    });
  }

  // Atomically find and delete an object based on query.
  findAndDeleteSchema(name) {
    return this._collection._mongoCollection.findOneAndDelete(_mongoSchemaQueryFromNameQuery(name));
  }
  insertSchema(schema) {
    return this._collection.insertOne(schema).then(() => mongoSchemaToParseSchema(schema)).catch(error => {
      if (error.code === 11000) {
        //Mongo's duplicate key error
        throw new _node.default.Error(_node.default.Error.DUPLICATE_VALUE, 'Class already exists.');
      } else {
        throw error;
      }
    });
  }
  updateSchema(name, update) {
    return this._collection.updateOne(_mongoSchemaQueryFromNameQuery(name), update);
  }
  upsertSchema(name, query, update) {
    return this._collection.upsertOne(_mongoSchemaQueryFromNameQuery(name, query), update);
  }

  // Add a field to the schema. If database does not support the field
  // type (e.g. mongo doesn't support more than one GeoPoint in a class) reject with an "Incorrect Type"
  // Parse error with a desciptive message. If the field already exists, this function must
  // not modify the schema, and must reject with DUPLICATE_VALUE error.
  // If this is called for a class that doesn't exist, this function must create that class.

  // TODO: throw an error if an unsupported field type is passed. Deciding whether a type is supported
  // should be the job of the adapter. Some adapters may not support GeoPoint at all. Others may
  // Support additional types that Mongo doesn't, like Money, or something.

  // TODO: don't spend an extra query on finding the schema if the type we are trying to add isn't a GeoPoint.
  addFieldIfNotExists(className, fieldName, fieldType) {
    return this._fetchOneSchemaFrom_SCHEMA(className).then(schema => {
      // If a field with this name already exists, it will be handled elsewhere.
      if (schema.fields[fieldName] !== undefined) {
        return;
      }
      // The schema exists. Check for existing GeoPoints.
      if (fieldType.type === 'GeoPoint') {
        // Make sure there are not other geopoint fields
        if (Object.keys(schema.fields).some(existingField => schema.fields[existingField].type === 'GeoPoint')) {
          throw new _node.default.Error(_node.default.Error.INCORRECT_TYPE, 'MongoDB only supports one GeoPoint field in a class.');
        }
      }
      return;
    }, error => {
      // If error is undefined, the schema doesn't exist, and we can create the schema with the field.
      // If some other error, reject with it.
      if (error === undefined) {
        return;
      }
      throw error;
    }).then(() => {
      const {
        type,
        targetClass,
        ...fieldOptions
      } = fieldType;
      // We use $exists and $set to avoid overwriting the field type if it
      // already exists. (it could have added inbetween the last query and the update)
      if (fieldOptions && Object.keys(fieldOptions).length > 0) {
        return this.upsertSchema(className, {
          [fieldName]: {
            $exists: false
          }
        }, {
          $set: {
            [fieldName]: parseFieldTypeToMongoFieldType({
              type,
              targetClass
            }),
            [`_metadata.fields_options.${fieldName}`]: fieldOptions
          }
        });
      } else {
        return this.upsertSchema(className, {
          [fieldName]: {
            $exists: false
          }
        }, {
          $set: {
            [fieldName]: parseFieldTypeToMongoFieldType({
              type,
              targetClass
            })
          }
        });
      }
    });
  }
  async updateFieldOptions(className, fieldName, fieldType) {
    const {
      ...fieldOptions
    } = fieldType;
    delete fieldOptions.type;
    delete fieldOptions.targetClass;
    await this.upsertSchema(className, {
      [fieldName]: {
        $exists: true
      }
    }, {
      $set: {
        [`_metadata.fields_options.${fieldName}`]: fieldOptions
      }
    });
  }
}

// Exported for testing reasons and because we haven't moved all mongo schema format
// related logic into the database adapter yet.
MongoSchemaCollection._TESTmongoSchemaToParseSchema = mongoSchemaToParseSchema;
MongoSchemaCollection.parseFieldTypeToMongoFieldType = parseFieldTypeToMongoFieldType;
var _default = exports.default = MongoSchemaCollection;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJuYW1lcyI6WyJfTW9uZ29Db2xsZWN0aW9uIiwiX2ludGVyb3BSZXF1aXJlRGVmYXVsdCIsInJlcXVpcmUiLCJfbm9kZSIsImUiLCJfX2VzTW9kdWxlIiwiZGVmYXVsdCIsIm1vbmdvRmllbGRUb1BhcnNlU2NoZW1hRmllbGQiLCJ0eXBlIiwidGFyZ2V0Q2xhc3MiLCJzbGljZSIsInN0YXJ0c1dpdGgiLCJsZW5ndGgiLCJub25GaWVsZFNjaGVtYUtleXMiLCJtb25nb1NjaGVtYUZpZWxkc1RvUGFyc2VTY2hlbWFGaWVsZHMiLCJzY2hlbWEiLCJmaWVsZE5hbWVzIiwiT2JqZWN0Iiwia2V5cyIsImZpbHRlciIsImtleSIsImluZGV4T2YiLCJyZXNwb25zZSIsInJlZHVjZSIsIm9iaiIsImZpZWxkTmFtZSIsIl9tZXRhZGF0YSIsImZpZWxkc19vcHRpb25zIiwiYXNzaWduIiwiQUNMIiwiY3JlYXRlZEF0IiwidXBkYXRlZEF0Iiwib2JqZWN0SWQiLCJlbXB0eUNMUFMiLCJmcmVlemUiLCJmaW5kIiwiY291bnQiLCJnZXQiLCJjcmVhdGUiLCJ1cGRhdGUiLCJkZWxldGUiLCJhZGRGaWVsZCIsInByb3RlY3RlZEZpZWxkcyIsImRlZmF1bHRDTFBTIiwicmVhZCIsIndyaXRlIiwibW9uZ29TY2hlbWFUb1BhcnNlU2NoZW1hIiwibW9uZ29TY2hlbWEiLCJjbHBzIiwiaW5kZXhlcyIsImNsYXNzX3Blcm1pc3Npb25zIiwiY2xhc3NOYW1lIiwiX2lkIiwiZmllbGRzIiwiY2xhc3NMZXZlbFBlcm1pc3Npb25zIiwiX21vbmdvU2NoZW1hUXVlcnlGcm9tTmFtZVF1ZXJ5IiwibmFtZSIsInF1ZXJ5Iiwib2JqZWN0IiwiZm9yRWFjaCIsInBhcnNlRmllbGRUeXBlVG9Nb25nb0ZpZWxkVHlwZSIsIk1vbmdvU2NoZW1hQ29sbGVjdGlvbiIsImNvbnN0cnVjdG9yIiwiY29sbGVjdGlvbiIsIl9jb2xsZWN0aW9uIiwiX2ZldGNoQWxsU2NoZW1hc0Zyb21fU0NIRU1BIiwiX3Jhd0ZpbmQiLCJ0aGVuIiwic2NoZW1hcyIsIm1hcCIsIl9mZXRjaE9uZVNjaGVtYUZyb21fU0NIRU1BIiwibGltaXQiLCJyZXN1bHRzIiwidW5kZWZpbmVkIiwiZmluZEFuZERlbGV0ZVNjaGVtYSIsIl9tb25nb0NvbGxlY3Rpb24iLCJmaW5kT25lQW5kRGVsZXRlIiwiaW5zZXJ0U2NoZW1hIiwiaW5zZXJ0T25lIiwiY2F0Y2giLCJlcnJvciIsImNvZGUiLCJQYXJzZSIsIkVycm9yIiwiRFVQTElDQVRFX1ZBTFVFIiwidXBkYXRlU2NoZW1hIiwidXBkYXRlT25lIiwidXBzZXJ0U2NoZW1hIiwidXBzZXJ0T25lIiwiYWRkRmllbGRJZk5vdEV4aXN0cyIsImZpZWxkVHlwZSIsInNvbWUiLCJleGlzdGluZ0ZpZWxkIiwiSU5DT1JSRUNUX1RZUEUiLCJmaWVsZE9wdGlvbnMiLCIkZXhpc3RzIiwiJHNldCIsInVwZGF0ZUZpZWxkT3B0aW9ucyIsIl9URVNUbW9uZ29TY2hlbWFUb1BhcnNlU2NoZW1hIiwiX2RlZmF1bHQiLCJleHBvcnRzIl0sInNvdXJjZXMiOlsiLi4vLi4vLi4vLi4vc3JjL0FkYXB0ZXJzL1N0b3JhZ2UvTW9uZ28vTW9uZ29TY2hlbWFDb2xsZWN0aW9uLmpzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBNb25nb0NvbGxlY3Rpb24gZnJvbSAnLi9Nb25nb0NvbGxlY3Rpb24nO1xuaW1wb3J0IFBhcnNlIGZyb20gJ3BhcnNlL25vZGUnO1xuXG5mdW5jdGlvbiBtb25nb0ZpZWxkVG9QYXJzZVNjaGVtYUZpZWxkKHR5cGUpIHtcbiAgaWYgKHR5cGVbMF0gPT09ICcqJykge1xuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiAnUG9pbnRlcicsXG4gICAgICB0YXJnZXRDbGFzczogdHlwZS5zbGljZSgxKSxcbiAgICB9O1xuICB9XG4gIGlmICh0eXBlLnN0YXJ0c1dpdGgoJ3JlbGF0aW9uPCcpKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6ICdSZWxhdGlvbicsXG4gICAgICB0YXJnZXRDbGFzczogdHlwZS5zbGljZSgncmVsYXRpb248Jy5sZW5ndGgsIHR5cGUubGVuZ3RoIC0gMSksXG4gICAgfTtcbiAgfVxuICBzd2l0Y2ggKHR5cGUpIHtcbiAgICBjYXNlICdudW1iZXInOlxuICAgICAgcmV0dXJuIHsgdHlwZTogJ051bWJlcicgfTtcbiAgICBjYXNlICdzdHJpbmcnOlxuICAgICAgcmV0dXJuIHsgdHlwZTogJ1N0cmluZycgfTtcbiAgICBjYXNlICdib29sZWFuJzpcbiAgICAgIHJldHVybiB7IHR5cGU6ICdCb29sZWFuJyB9O1xuICAgIGNhc2UgJ2RhdGUnOlxuICAgICAgcmV0dXJuIHsgdHlwZTogJ0RhdGUnIH07XG4gICAgY2FzZSAnbWFwJzpcbiAgICBjYXNlICdvYmplY3QnOlxuICAgICAgcmV0dXJuIHsgdHlwZTogJ09iamVjdCcgfTtcbiAgICBjYXNlICdhcnJheSc6XG4gICAgICByZXR1cm4geyB0eXBlOiAnQXJyYXknIH07XG4gICAgY2FzZSAnZ2VvcG9pbnQnOlxuICAgICAgcmV0dXJuIHsgdHlwZTogJ0dlb1BvaW50JyB9O1xuICAgIGNhc2UgJ2ZpbGUnOlxuICAgICAgcmV0dXJuIHsgdHlwZTogJ0ZpbGUnIH07XG4gICAgY2FzZSAnYnl0ZXMnOlxuICAgICAgcmV0dXJuIHsgdHlwZTogJ0J5dGVzJyB9O1xuICAgIGNhc2UgJ3BvbHlnb24nOlxuICAgICAgcmV0dXJuIHsgdHlwZTogJ1BvbHlnb24nIH07XG4gIH1cbn1cblxuY29uc3Qgbm9uRmllbGRTY2hlbWFLZXlzID0gWydfaWQnLCAnX21ldGFkYXRhJywgJ19jbGllbnRfcGVybWlzc2lvbnMnXTtcbmZ1bmN0aW9uIG1vbmdvU2NoZW1hRmllbGRzVG9QYXJzZVNjaGVtYUZpZWxkcyhzY2hlbWEpIHtcbiAgdmFyIGZpZWxkTmFtZXMgPSBPYmplY3Qua2V5cyhzY2hlbWEpLmZpbHRlcihrZXkgPT4gbm9uRmllbGRTY2hlbWFLZXlzLmluZGV4T2Yoa2V5KSA9PT0gLTEpO1xuICB2YXIgcmVzcG9uc2UgPSBmaWVsZE5hbWVzLnJlZHVjZSgob2JqLCBmaWVsZE5hbWUpID0+IHtcbiAgICBvYmpbZmllbGROYW1lXSA9IG1vbmdvRmllbGRUb1BhcnNlU2NoZW1hRmllbGQoc2NoZW1hW2ZpZWxkTmFtZV0pO1xuICAgIGlmIChcbiAgICAgIHNjaGVtYS5fbWV0YWRhdGEgJiZcbiAgICAgIHNjaGVtYS5fbWV0YWRhdGEuZmllbGRzX29wdGlvbnMgJiZcbiAgICAgIHNjaGVtYS5fbWV0YWRhdGEuZmllbGRzX29wdGlvbnNbZmllbGROYW1lXVxuICAgICkge1xuICAgICAgb2JqW2ZpZWxkTmFtZV0gPSBPYmplY3QuYXNzaWduKFxuICAgICAgICB7fSxcbiAgICAgICAgb2JqW2ZpZWxkTmFtZV0sXG4gICAgICAgIHNjaGVtYS5fbWV0YWRhdGEuZmllbGRzX29wdGlvbnNbZmllbGROYW1lXVxuICAgICAgKTtcbiAgICB9XG4gICAgcmV0dXJuIG9iajtcbiAgfSwge30pO1xuICByZXNwb25zZS5BQ0wgPSB7IHR5cGU6ICdBQ0wnIH07XG4gIHJlc3BvbnNlLmNyZWF0ZWRBdCA9IHsgdHlwZTogJ0RhdGUnIH07XG4gIHJlc3BvbnNlLnVwZGF0ZWRBdCA9IHsgdHlwZTogJ0RhdGUnIH07XG4gIHJlc3BvbnNlLm9iamVjdElkID0geyB0eXBlOiAnU3RyaW5nJyB9O1xuICByZXR1cm4gcmVzcG9uc2U7XG59XG5cbmNvbnN0IGVtcHR5Q0xQUyA9IE9iamVjdC5mcmVlemUoe1xuICBmaW5kOiB7fSxcbiAgY291bnQ6IHt9LFxuICBnZXQ6IHt9LFxuICBjcmVhdGU6IHt9LFxuICB1cGRhdGU6IHt9LFxuICBkZWxldGU6IHt9LFxuICBhZGRGaWVsZDoge30sXG4gIHByb3RlY3RlZEZpZWxkczoge30sXG59KTtcblxuY29uc3QgZGVmYXVsdENMUFMgPSBPYmplY3QuZnJlZXplKHtcbiAgQUNMOiB7XG4gICAgJyonOiB7XG4gICAgICByZWFkOiB0cnVlLFxuICAgICAgd3JpdGU6IHRydWUsXG4gICAgfSxcbiAgfSxcbiAgZmluZDogeyAnKic6IHRydWUgfSxcbiAgY291bnQ6IHsgJyonOiB0cnVlIH0sXG4gIGdldDogeyAnKic6IHRydWUgfSxcbiAgY3JlYXRlOiB7ICcqJzogdHJ1ZSB9LFxuICB1cGRhdGU6IHsgJyonOiB0cnVlIH0sXG4gIGRlbGV0ZTogeyAnKic6IHRydWUgfSxcbiAgYWRkRmllbGQ6IHsgJyonOiB0cnVlIH0sXG4gIHByb3RlY3RlZEZpZWxkczogeyAnKic6IFtdIH0sXG59KTtcblxuZnVuY3Rpb24gbW9uZ29TY2hlbWFUb1BhcnNlU2NoZW1hKG1vbmdvU2NoZW1hKSB7XG4gIGxldCBjbHBzID0gZGVmYXVsdENMUFM7XG4gIGxldCBpbmRleGVzID0ge307XG4gIGlmIChtb25nb1NjaGVtYS5fbWV0YWRhdGEpIHtcbiAgICBpZiAobW9uZ29TY2hlbWEuX21ldGFkYXRhLmNsYXNzX3Blcm1pc3Npb25zKSB7XG4gICAgICBjbHBzID0geyAuLi5lbXB0eUNMUFMsIC4uLm1vbmdvU2NoZW1hLl9tZXRhZGF0YS5jbGFzc19wZXJtaXNzaW9ucyB9O1xuICAgIH1cbiAgICBpZiAobW9uZ29TY2hlbWEuX21ldGFkYXRhLmluZGV4ZXMpIHtcbiAgICAgIGluZGV4ZXMgPSB7IC4uLm1vbmdvU2NoZW1hLl9tZXRhZGF0YS5pbmRleGVzIH07XG4gICAgfVxuICB9XG4gIHJldHVybiB7XG4gICAgY2xhc3NOYW1lOiBtb25nb1NjaGVtYS5faWQsXG4gICAgZmllbGRzOiBtb25nb1NjaGVtYUZpZWxkc1RvUGFyc2VTY2hlbWFGaWVsZHMobW9uZ29TY2hlbWEpLFxuICAgIGNsYXNzTGV2ZWxQZXJtaXNzaW9uczogY2xwcyxcbiAgICBpbmRleGVzOiBpbmRleGVzLFxuICB9O1xufVxuXG5mdW5jdGlvbiBfbW9uZ29TY2hlbWFRdWVyeUZyb21OYW1lUXVlcnkobmFtZTogc3RyaW5nLCBxdWVyeSkge1xuICBjb25zdCBvYmplY3QgPSB7IF9pZDogbmFtZSB9O1xuICBpZiAocXVlcnkpIHtcbiAgICBPYmplY3Qua2V5cyhxdWVyeSkuZm9yRWFjaChrZXkgPT4ge1xuICAgICAgb2JqZWN0W2tleV0gPSBxdWVyeVtrZXldO1xuICAgIH0pO1xuICB9XG4gIHJldHVybiBvYmplY3Q7XG59XG5cbi8vIFJldHVybnMgYSB0eXBlIHN1aXRhYmxlIGZvciBpbnNlcnRpbmcgaW50byBtb25nbyBfU0NIRU1BIGNvbGxlY3Rpb24uXG4vLyBEb2VzIG5vIHZhbGlkYXRpb24uIFRoYXQgaXMgZXhwZWN0ZWQgdG8gYmUgZG9uZSBpbiBQYXJzZSBTZXJ2ZXIuXG5mdW5jdGlvbiBwYXJzZUZpZWxkVHlwZVRvTW9uZ29GaWVsZFR5cGUoeyB0eXBlLCB0YXJnZXRDbGFzcyB9KSB7XG4gIHN3aXRjaCAodHlwZSkge1xuICAgIGNhc2UgJ1BvaW50ZXInOlxuICAgICAgcmV0dXJuIGAqJHt0YXJnZXRDbGFzc31gO1xuICAgIGNhc2UgJ1JlbGF0aW9uJzpcbiAgICAgIHJldHVybiBgcmVsYXRpb248JHt0YXJnZXRDbGFzc30+YDtcbiAgICBjYXNlICdOdW1iZXInOlxuICAgICAgcmV0dXJuICdudW1iZXInO1xuICAgIGNhc2UgJ1N0cmluZyc6XG4gICAgICByZXR1cm4gJ3N0cmluZyc7XG4gICAgY2FzZSAnQm9vbGVhbic6XG4gICAgICByZXR1cm4gJ2Jvb2xlYW4nO1xuICAgIGNhc2UgJ0RhdGUnOlxuICAgICAgcmV0dXJuICdkYXRlJztcbiAgICBjYXNlICdPYmplY3QnOlxuICAgICAgcmV0dXJuICdvYmplY3QnO1xuICAgIGNhc2UgJ0FycmF5JzpcbiAgICAgIHJldHVybiAnYXJyYXknO1xuICAgIGNhc2UgJ0dlb1BvaW50JzpcbiAgICAgIHJldHVybiAnZ2VvcG9pbnQnO1xuICAgIGNhc2UgJ0ZpbGUnOlxuICAgICAgcmV0dXJuICdmaWxlJztcbiAgICBjYXNlICdCeXRlcyc6XG4gICAgICByZXR1cm4gJ2J5dGVzJztcbiAgICBjYXNlICdQb2x5Z29uJzpcbiAgICAgIHJldHVybiAncG9seWdvbic7XG4gIH1cbn1cblxuY2xhc3MgTW9uZ29TY2hlbWFDb2xsZWN0aW9uIHtcbiAgX2NvbGxlY3Rpb246IE1vbmdvQ29sbGVjdGlvbjtcblxuICBjb25zdHJ1Y3Rvcihjb2xsZWN0aW9uOiBNb25nb0NvbGxlY3Rpb24pIHtcbiAgICB0aGlzLl9jb2xsZWN0aW9uID0gY29sbGVjdGlvbjtcbiAgfVxuXG4gIF9mZXRjaEFsbFNjaGVtYXNGcm9tX1NDSEVNQSgpIHtcbiAgICByZXR1cm4gdGhpcy5fY29sbGVjdGlvbi5fcmF3RmluZCh7fSkudGhlbihzY2hlbWFzID0+IHNjaGVtYXMubWFwKG1vbmdvU2NoZW1hVG9QYXJzZVNjaGVtYSkpO1xuICB9XG5cbiAgX2ZldGNoT25lU2NoZW1hRnJvbV9TQ0hFTUEobmFtZTogc3RyaW5nKSB7XG4gICAgcmV0dXJuIHRoaXMuX2NvbGxlY3Rpb25cbiAgICAgIC5fcmF3RmluZChfbW9uZ29TY2hlbWFRdWVyeUZyb21OYW1lUXVlcnkobmFtZSksIHsgbGltaXQ6IDEgfSlcbiAgICAgIC50aGVuKHJlc3VsdHMgPT4ge1xuICAgICAgICBpZiAocmVzdWx0cy5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgICByZXR1cm4gbW9uZ29TY2hlbWFUb1BhcnNlU2NoZW1hKHJlc3VsdHNbMF0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRocm93IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gIH1cblxuICAvLyBBdG9taWNhbGx5IGZpbmQgYW5kIGRlbGV0ZSBhbiBvYmplY3QgYmFzZWQgb24gcXVlcnkuXG4gIGZpbmRBbmREZWxldGVTY2hlbWEobmFtZTogc3RyaW5nKSB7XG4gICAgcmV0dXJuIHRoaXMuX2NvbGxlY3Rpb24uX21vbmdvQ29sbGVjdGlvbi5maW5kT25lQW5kRGVsZXRlKF9tb25nb1NjaGVtYVF1ZXJ5RnJvbU5hbWVRdWVyeShuYW1lKSk7XG4gIH1cblxuICBpbnNlcnRTY2hlbWEoc2NoZW1hOiBhbnkpIHtcbiAgICByZXR1cm4gdGhpcy5fY29sbGVjdGlvblxuICAgICAgLmluc2VydE9uZShzY2hlbWEpXG4gICAgICAudGhlbigoKSA9PiBtb25nb1NjaGVtYVRvUGFyc2VTY2hlbWEoc2NoZW1hKSlcbiAgICAgIC5jYXRjaChlcnJvciA9PiB7XG4gICAgICAgIGlmIChlcnJvci5jb2RlID09PSAxMTAwMCkge1xuICAgICAgICAgIC8vTW9uZ28ncyBkdXBsaWNhdGUga2V5IGVycm9yXG4gICAgICAgICAgdGhyb3cgbmV3IFBhcnNlLkVycm9yKFBhcnNlLkVycm9yLkRVUExJQ0FURV9WQUxVRSwgJ0NsYXNzIGFscmVhZHkgZXhpc3RzLicpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgfVxuXG4gIHVwZGF0ZVNjaGVtYShuYW1lOiBzdHJpbmcsIHVwZGF0ZSkge1xuICAgIHJldHVybiB0aGlzLl9jb2xsZWN0aW9uLnVwZGF0ZU9uZShfbW9uZ29TY2hlbWFRdWVyeUZyb21OYW1lUXVlcnkobmFtZSksIHVwZGF0ZSk7XG4gIH1cblxuICB1cHNlcnRTY2hlbWEobmFtZTogc3RyaW5nLCBxdWVyeTogc3RyaW5nLCB1cGRhdGUpIHtcbiAgICByZXR1cm4gdGhpcy5fY29sbGVjdGlvbi51cHNlcnRPbmUoX21vbmdvU2NoZW1hUXVlcnlGcm9tTmFtZVF1ZXJ5KG5hbWUsIHF1ZXJ5KSwgdXBkYXRlKTtcbiAgfVxuXG4gIC8vIEFkZCBhIGZpZWxkIHRvIHRoZSBzY2hlbWEuIElmIGRhdGFiYXNlIGRvZXMgbm90IHN1cHBvcnQgdGhlIGZpZWxkXG4gIC8vIHR5cGUgKGUuZy4gbW9uZ28gZG9lc24ndCBzdXBwb3J0IG1vcmUgdGhhbiBvbmUgR2VvUG9pbnQgaW4gYSBjbGFzcykgcmVqZWN0IHdpdGggYW4gXCJJbmNvcnJlY3QgVHlwZVwiXG4gIC8vIFBhcnNlIGVycm9yIHdpdGggYSBkZXNjaXB0aXZlIG1lc3NhZ2UuIElmIHRoZSBmaWVsZCBhbHJlYWR5IGV4aXN0cywgdGhpcyBmdW5jdGlvbiBtdXN0XG4gIC8vIG5vdCBtb2RpZnkgdGhlIHNjaGVtYSwgYW5kIG11c3QgcmVqZWN0IHdpdGggRFVQTElDQVRFX1ZBTFVFIGVycm9yLlxuICAvLyBJZiB0aGlzIGlzIGNhbGxlZCBmb3IgYSBjbGFzcyB0aGF0IGRvZXNuJ3QgZXhpc3QsIHRoaXMgZnVuY3Rpb24gbXVzdCBjcmVhdGUgdGhhdCBjbGFzcy5cblxuICAvLyBUT0RPOiB0aHJvdyBhbiBlcnJvciBpZiBhbiB1bnN1cHBvcnRlZCBmaWVsZCB0eXBlIGlzIHBhc3NlZC4gRGVjaWRpbmcgd2hldGhlciBhIHR5cGUgaXMgc3VwcG9ydGVkXG4gIC8vIHNob3VsZCBiZSB0aGUgam9iIG9mIHRoZSBhZGFwdGVyLiBTb21lIGFkYXB0ZXJzIG1heSBub3Qgc3VwcG9ydCBHZW9Qb2ludCBhdCBhbGwuIE90aGVycyBtYXlcbiAgLy8gU3VwcG9ydCBhZGRpdGlvbmFsIHR5cGVzIHRoYXQgTW9uZ28gZG9lc24ndCwgbGlrZSBNb25leSwgb3Igc29tZXRoaW5nLlxuXG4gIC8vIFRPRE86IGRvbid0IHNwZW5kIGFuIGV4dHJhIHF1ZXJ5IG9uIGZpbmRpbmcgdGhlIHNjaGVtYSBpZiB0aGUgdHlwZSB3ZSBhcmUgdHJ5aW5nIHRvIGFkZCBpc24ndCBhIEdlb1BvaW50LlxuICBhZGRGaWVsZElmTm90RXhpc3RzKGNsYXNzTmFtZTogc3RyaW5nLCBmaWVsZE5hbWU6IHN0cmluZywgZmllbGRUeXBlOiBzdHJpbmcpIHtcbiAgICByZXR1cm4gdGhpcy5fZmV0Y2hPbmVTY2hlbWFGcm9tX1NDSEVNQShjbGFzc05hbWUpXG4gICAgICAudGhlbihcbiAgICAgICAgc2NoZW1hID0+IHtcbiAgICAgICAgICAvLyBJZiBhIGZpZWxkIHdpdGggdGhpcyBuYW1lIGFscmVhZHkgZXhpc3RzLCBpdCB3aWxsIGJlIGhhbmRsZWQgZWxzZXdoZXJlLlxuICAgICAgICAgIGlmIChzY2hlbWEuZmllbGRzW2ZpZWxkTmFtZV0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgICAvLyBUaGUgc2NoZW1hIGV4aXN0cy4gQ2hlY2sgZm9yIGV4aXN0aW5nIEdlb1BvaW50cy5cbiAgICAgICAgICBpZiAoZmllbGRUeXBlLnR5cGUgPT09ICdHZW9Qb2ludCcpIHtcbiAgICAgICAgICAgIC8vIE1ha2Ugc3VyZSB0aGVyZSBhcmUgbm90IG90aGVyIGdlb3BvaW50IGZpZWxkc1xuICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICBPYmplY3Qua2V5cyhzY2hlbWEuZmllbGRzKS5zb21lKFxuICAgICAgICAgICAgICAgIGV4aXN0aW5nRmllbGQgPT4gc2NoZW1hLmZpZWxkc1tleGlzdGluZ0ZpZWxkXS50eXBlID09PSAnR2VvUG9pbnQnXG4gICAgICAgICAgICAgIClcbiAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICB0aHJvdyBuZXcgUGFyc2UuRXJyb3IoXG4gICAgICAgICAgICAgICAgUGFyc2UuRXJyb3IuSU5DT1JSRUNUX1RZUEUsXG4gICAgICAgICAgICAgICAgJ01vbmdvREIgb25seSBzdXBwb3J0cyBvbmUgR2VvUG9pbnQgZmllbGQgaW4gYSBjbGFzcy4nXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfSxcbiAgICAgICAgZXJyb3IgPT4ge1xuICAgICAgICAgIC8vIElmIGVycm9yIGlzIHVuZGVmaW5lZCwgdGhlIHNjaGVtYSBkb2Vzbid0IGV4aXN0LCBhbmQgd2UgY2FuIGNyZWF0ZSB0aGUgc2NoZW1hIHdpdGggdGhlIGZpZWxkLlxuICAgICAgICAgIC8vIElmIHNvbWUgb3RoZXIgZXJyb3IsIHJlamVjdCB3aXRoIGl0LlxuICAgICAgICAgIGlmIChlcnJvciA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICB9XG4gICAgICApXG4gICAgICAudGhlbigoKSA9PiB7XG4gICAgICAgIGNvbnN0IHsgdHlwZSwgdGFyZ2V0Q2xhc3MsIC4uLmZpZWxkT3B0aW9ucyB9ID0gZmllbGRUeXBlO1xuICAgICAgICAvLyBXZSB1c2UgJGV4aXN0cyBhbmQgJHNldCB0byBhdm9pZCBvdmVyd3JpdGluZyB0aGUgZmllbGQgdHlwZSBpZiBpdFxuICAgICAgICAvLyBhbHJlYWR5IGV4aXN0cy4gKGl0IGNvdWxkIGhhdmUgYWRkZWQgaW5iZXR3ZWVuIHRoZSBsYXN0IHF1ZXJ5IGFuZCB0aGUgdXBkYXRlKVxuICAgICAgICBpZiAoZmllbGRPcHRpb25zICYmIE9iamVjdC5rZXlzKGZpZWxkT3B0aW9ucykubGVuZ3RoID4gMCkge1xuICAgICAgICAgIHJldHVybiB0aGlzLnVwc2VydFNjaGVtYShcbiAgICAgICAgICAgIGNsYXNzTmFtZSxcbiAgICAgICAgICAgIHsgW2ZpZWxkTmFtZV06IHsgJGV4aXN0czogZmFsc2UgfSB9LFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAkc2V0OiB7XG4gICAgICAgICAgICAgICAgW2ZpZWxkTmFtZV06IHBhcnNlRmllbGRUeXBlVG9Nb25nb0ZpZWxkVHlwZSh7XG4gICAgICAgICAgICAgICAgICB0eXBlLFxuICAgICAgICAgICAgICAgICAgdGFyZ2V0Q2xhc3MsXG4gICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAgICAgW2BfbWV0YWRhdGEuZmllbGRzX29wdGlvbnMuJHtmaWVsZE5hbWV9YF06IGZpZWxkT3B0aW9ucyxcbiAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH1cbiAgICAgICAgICApO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiB0aGlzLnVwc2VydFNjaGVtYShcbiAgICAgICAgICAgIGNsYXNzTmFtZSxcbiAgICAgICAgICAgIHsgW2ZpZWxkTmFtZV06IHsgJGV4aXN0czogZmFsc2UgfSB9LFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAkc2V0OiB7XG4gICAgICAgICAgICAgICAgW2ZpZWxkTmFtZV06IHBhcnNlRmllbGRUeXBlVG9Nb25nb0ZpZWxkVHlwZSh7XG4gICAgICAgICAgICAgICAgICB0eXBlLFxuICAgICAgICAgICAgICAgICAgdGFyZ2V0Q2xhc3MsXG4gICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9XG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gIH1cblxuICBhc3luYyB1cGRhdGVGaWVsZE9wdGlvbnMoY2xhc3NOYW1lOiBzdHJpbmcsIGZpZWxkTmFtZTogc3RyaW5nLCBmaWVsZFR5cGU6IGFueSkge1xuICAgIGNvbnN0IHsgLi4uZmllbGRPcHRpb25zIH0gPSBmaWVsZFR5cGU7XG4gICAgZGVsZXRlIGZpZWxkT3B0aW9ucy50eXBlO1xuICAgIGRlbGV0ZSBmaWVsZE9wdGlvbnMudGFyZ2V0Q2xhc3M7XG5cbiAgICBhd2FpdCB0aGlzLnVwc2VydFNjaGVtYShcbiAgICAgIGNsYXNzTmFtZSxcbiAgICAgIHsgW2ZpZWxkTmFtZV06IHsgJGV4aXN0czogdHJ1ZSB9IH0sXG4gICAgICB7XG4gICAgICAgICRzZXQ6IHtcbiAgICAgICAgICBbYF9tZXRhZGF0YS5maWVsZHNfb3B0aW9ucy4ke2ZpZWxkTmFtZX1gXTogZmllbGRPcHRpb25zLFxuICAgICAgICB9LFxuICAgICAgfVxuICAgICk7XG4gIH1cbn1cblxuLy8gRXhwb3J0ZWQgZm9yIHRlc3RpbmcgcmVhc29ucyBhbmQgYmVjYXVzZSB3ZSBoYXZlbid0IG1vdmVkIGFsbCBtb25nbyBzY2hlbWEgZm9ybWF0XG4vLyByZWxhdGVkIGxvZ2ljIGludG8gdGhlIGRhdGFiYXNlIGFkYXB0ZXIgeWV0LlxuTW9uZ29TY2hlbWFDb2xsZWN0aW9uLl9URVNUbW9uZ29TY2hlbWFUb1BhcnNlU2NoZW1hID0gbW9uZ29TY2hlbWFUb1BhcnNlU2NoZW1hO1xuTW9uZ29TY2hlbWFDb2xsZWN0aW9uLnBhcnNlRmllbGRUeXBlVG9Nb25nb0ZpZWxkVHlwZSA9IHBhcnNlRmllbGRUeXBlVG9Nb25nb0ZpZWxkVHlwZTtcblxu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